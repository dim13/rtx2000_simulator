















( My Editor and extensions load screen)

6 VIEWS EDIT.BLK   ( make the editor viewable)
OPEN EDIT.BLK

3 29 THRU

CR .( Screen editor and extensions loaded )
























( Set path)   HEX

CODE @PATH ( a - \ read the current path to an address)
   AX POP AX INC  SI PUSH  AX SI MOV  0 # DL MOV
   47 # AH MOV  21 INT  SI POP  NEXT C;

CODE !PATH ( a - f)
   DX POP  3B # AH MOV  21 INT
   3 # AX CMP  0= IF  -1 # AX MOV  ELSE  AX AX XOR THEN
   AX PUSH  NEXT  C;

: .PATH   0 19 BDOS  41 + EMIT  ." :\" HERE @PATH  HERE 1+
   BEGIN  DUP C@ WHILE DUP C@ EMIT 1+ REPEAT DROP ;
: CD   BL WORD  COUNT DUP 0= IF .PATH 2DROP
   ELSE  OVER +  0 SWAP C!  !PATH  ABORT" Invalid path "
   THEN ;
( Bios video display interface)   HEX

CODE AT ( x y)
   AX POP  AL DH MOV  AX POP  AL DL MOV
   2 # AH MOV  0 # BH MOV  10 INT  NEXT C;

CODE XY@ ( - x y)
   3 # AH MOV  0 # BH MOV  10 INT
   AX AX SUB  DL AL MOV  AX PUSH  DH AL MOV  AX PUSH  NEXT C;

VARIABLE VSEG ( the video page number)
: COLOR   B800 VSEG ! ;    COLOR ( my default)
: MONO    B000 VSEG ! ;

CODE VMODE@ ( - n \ lsb= vmode, msb=vpage)
   0F # AH MOV  10 INT  AH AH SUB  BH AH MOV  AX PUSH  NEXT C;
( Extended memory access)   DECIMAL

CODE MY-SEG ( - seg)   CS PUSH  NEXT C;

CODE L@ ( seg off - n)
   BX POP  DS AX MOV  DS POP  0 [BX] PUSH  AX DS MOV  NEXT C;
CODE L! ( n seg off)
   BX POP  DS AX MOV  DS POP  0 [BX] POP  AX DS MOV  NEXT C;

CODE LCMOVE ( seg-off-f seg-off-t #)
   CLD  IP BX MOV
   CX POP  DI POP ES POP  SI POP DS POP  REP  BYTE MOVS
   CS AX MOV  AX DS MOV  AX ES MOV  BX IP MOV  NEXT  C;

: L2@ ( seg off - d)   2DUP 2+ L@  ROT ROT  L@ ;
: L2! ( d seg off)   ROT >R  2DUP R> ROT ROT L!  2+ L! ;
( Faster crt interface)   HEX

VARIABLE ATTRIBUTE   7 ATTRIBUTE !    0 ,
VARIABLE BLANKING    0 BLANKING  !

LABEL +BLANKING
   BLANKING #) DX MOV  DX DX OR  0= IF  RET  THEN
   1 # BX MOV  3DA # DX MOV
   BEGIN  0 AL IN  BX AL TEST  0<> UNTIL
   3d8 # DX MOV  25 # AL MOV  0 AL OUT  RET  C;
LABEL -BLANKING
   BLANKING #) DX MOV  DX DX OR  0= IF  RET  THEN
   3D8 # DX MOV  2D # AL MOV  0 AL OUT  RET  C;



   ( Continued..)   HEX

CODE FTYPE ( a # x y)   CLD
   AX POP  0A0 # BX MOV  BX MUL
   DI POP  DI DI ADD  AX DI ADD
   CX POP  BX POP   SI PUSH  BX SI MOV
   HIDDEN VSEG  ASSEMBLER #) ES MOV   ATTRIBUTE #) AH MOV
   +BLANKING #) CALL
   BEGIN  AL LODS  AX STOS  CX DEC  0= UNTIL
   -BLANKING #) CALL
   SI POP  DS AX MOV  AX ES MOV  NEXT  END-CODE

CODE PAGE ( home and clear to end of screen)
   2 # AH MOV  0 # DX MOV  0 # BH MOV  10 INT
   20 # AL MOV  ATTRIBUTE #) BL MOV  0 # BH MOV
   7d0 # CX MOV  9 # AH MOV  10 INT  NEXT C;   ' PAGE IS DARK
( Listing)   DECIMAL

VARIABLE OLDSCR
: OTHER ( n - n)   DUP  SCR @ = NOT IF  SCR @ OLDSCR !  THEN ;

: FRAME
   PAGE  FILE?  CR ." SCR #"  16 0 DO  CR I 3 U.R  LOOP CR ;

: <LIST> ( scr)   0 MAX CAPACITY 1- MIN
   5 1 AT  DUP 5 U.R  DUP SCR !  BLOCK
   16 0 DO  DUP 64 4 I 2+ FTYPE  64 +  LOOP DROP ;

: LIST ( scr)   OTHER FRAME <LIST>  0 19 AT ;

: VIEW ( - <name>)   [ DOS ]  ' @VIEW  ?DUP
   IF   2* VIEW-FILES + PERFORM OPEN-FILE  THEN  LIST ;
   ( Listing)   DECIMAL

: ADV ( n)   SCR @ +  0 MAX  LIST ;
: L    0 ADV ;
: B   -1 ADV ;
: N    1 ADV ;

: G   SCR @ LOAD ;
: O   OLDSCR @ LIST ;

: Q   A L ;

: CASE   COMPILE OVER COMPILE = [COMPILE] IF COMPILE DROP ;
   IMMEDIATE
: ;THEN   COMPILE EXIT  [COMPILE] THEN ;   IMMEDIATE

( Blocks, Obliterate)

: CLEAN ( n)   BUFFER  1024 BLANK  UPDATE ;
: ?FLUSH ( n)   #BUFFERS MOD 0= IF FLUSH THEN ;

: BLOCKS ( f t #)
   >R  2DUP < IF ( backwards)
      R@ + 1-  SWAP  R@ + 1-  SWAP ( f' t')
      R> 0 DO  2DUP (COPY)  SWAP 1- SWAP 1-  I ?FLUSH  LOOP
   ELSE ( forwards)
      R> 0 DO  2DUP (COPY)  SWAP 1+ SWAP 1+  I ?FLUSH  LOOP
   THEN  2DROP  FLUSH  ;

: OBLITERATE ( f #)
   BOUNDS DO  I CLEAN  I ?FLUSH  LOOP  FLUSH ;

( MYEDIT - moving the cursor)

VOCABULARY MYEDIT   ONLY  FORTH ALSO  MYEDIT ALSO  DEFINITIONS

VARIABLE CURSOR
: ^C ( - a)   SCR @ BLOCK CURSOR @ + ;

: +C   CREATE , DOES> @ CURSOR @ + 1023 AND CURSOR ! ;

 -64 +C UP     64 +C DOWN     1 +C RIGHT
-256 +C UP4   256 +C DOWN4   -1 +C LEFT

: TAB   CURSOR @ 4 + 1020 AND CURSOR ! ;
: RETURN   CURSOR @ 64 +  960 AND  CURSOR ! ;

: HOME   0 CURSOR ! ;
   ( Screen interface)

: XY ( - x y)   CURSOR @ 64 /MOD  2 + SWAP 4 + SWAP ;

: PUT   XY AT ;

: #EOL ( - n)   64  CURSOR @ 63 AND - ;
: #EOS ( - n)   960 CURSOR @ - ;

: .EOL   ^C #EOL XY  FTYPE ;
: .EOS   CURSOR @ >R  BEGIN  .EOL RETURN  CURSOR @ 0= UNTIL
   R> CURSOR ! ;

: WIPE ( to end of screen)   ^C #EOS 64 +  BLANK .EOS UPDATE ;
: BLOT ( to end of line)     ^C #EOL BLANK .EOL UPDATE ;

   ( Status reporting)

CREATE SCREENS   10 ALLOT   SCREENS 10 ERASE
: .SCREENS   28 0 AT  ." others "
   10 0 DO  I SCREENS + @ 4 U.R  2 +LOOP ;

VARIABLE INSERTING
: .INS   65 0 AT
   INSERTING @ IF  ." ins"  ELSE ." ovr" THEN ;
: *INS   INSERTING @ 0= INSERTING !  .INS ;

VARIABLE LS
: .LS ( print the line stack)
   0 19 AT
   LS @ ?DUP IF  DUP 64 / 3 .R ." {"  PAD + 64 TYPE  ." }"
      ELSE  70 SPACES THEN ;
   ( Different screens)

: .CURSOR   18 0 AT  CURSOR @ 64 /MOD  3 .R 3 .R ;
: .STAT   .INS .LS .SCREENS ;

: ADV ( n)   SCR @ + <LIST> ;
: N   1 ADV ;               : B   -1 ADV  ;
: L   0 ADV .STAT ;         : SHADOW   Q L ;

: UNDO ( the edited screen)   DISCARD L ;

: MARK ( n)   2* SCREENS + SCR @ SWAP !  .SCREENS ;
: GOTO ( n)   2* SCREENS + @ ?DUP IF SCR ! L THEN ;

: TO-EOL   RETURN UP  ^C 64 -TRAILING
   DUP IF  1+  63 MIN  THEN  CURSOR @ +  CURSOR !  DROP ;
   ( Line stack)

: CUT ( the current line)
   64 LS +!  PAD LS @ +  DUP 64 BLANK  ^C SWAP #EOL CMOVE
   DOWN .LS ;
: PASTE ( to the current line)
   LS @ IF PAD LS @ + ^C #EOL CMOVE  UPDATE  .EOL  -64 LS +!
   UP .LS THEN ;

: <DELETE>
   #EOL 1- DUP  ?DUP IF  ^C DUP 1+ SWAP ROT CMOVE  THEN
   32 ^C ROT + C! UPDATE ;

: DELETE   <DELETE> .EOL ;
: BACKSPACE   LEFT  INSERTING @ IF DELETE THEN ;

   ( By words)

: <>END ( n - n f)   DUP 1024 < ;
: =BL ( n - n f)   ^C C@ 32 = ;
: <>BL ( n - n f)   ^C C@ 32 = 0= ;

: WORD>   0 BEGIN  <>END <>BL AND WHILE  1+ RIGHT  REPEAT
   BEGIN <>END =BL AND WHILE 1+ RIGHT REPEAT DROP ;
: <WORD   LEFT  0 BEGIN  <>END =BL AND WHILE  1+ LEFT  REPEAT
   BEGIN <>END <>BL AND WHILE 1+ LEFT REPEAT DROP RIGHT ;

: -WORD   CURSOR @  ^C  WORD> ^C  SWAP - SWAP CURSOR !  #EOL MIN
   ?DUP IF 0 DO <DELETE> LOOP .EOL THEN ;

: -DIALOG   0 21 AT  240 SPACES  0 22 AT ;
: DIALOG   -DIALOG  0 22 AT  ." cmd> " QUERY INTERPRET ;
   ( Split and join)

: SPLIT ( the line at the cursor)
   #EOS 0< NOT IF  ^C DUP 64 + #EOS CMOVE>
             ^C 64 BLANK  UPDATE  .EOS   THEN ;
: JOIN ( the lines at the cursor)
   #EOS 0< NOT IF  ^C DUP 64 + SWAP #EOS CMOVE
             ^C #EOS +   64 BLANK  UPDATE  .EOS  THEN ;

: OVERSTRIKE ( char)   ^C C!  ^C 1 XY FTYPE  RIGHT UPDATE ;

: <INSERT> ( char)   #EOL 1- ?DUP IF  ^C DUP 1+ ROT CMOVE>  THEN
   ^C C!  UPDATE ;
: INSERT ( char)   <INSERT> .EOL RIGHT ;

: CHARACTER ( c)   INSERTING @ IF INSERT ELSE OVERSTRIKE THEN ;
   ( Matching)
CODE $ZMATCH ( sa s# pa - a f)
   AX AX SUB  DX DX SUB
   BX POP   0 [BX] DL MOV  DX DEC  BX INC  0 [BX] AL MOV  BX INC
   CX POP  DI POP  SI PUSH
   BEGIN
      REPNZ BYTE SCAS  0<> IF
         SI POP  DI PUSH  CX PUSH  NEXT  THEN
      CX PUSH  DI PUSH
      DX CX MOV  BX SI MOV
      REPZ BYTE CMPS  0= IF
         DI POP  DI DEC  CX POP
         SI POP  DI PUSH  CX PUSH  NEXT  THEN
      DI POP  CX POP
   AGAIN
NEXT C;
   ( Searching)

CREATE $FIND  80 ALLOT

: PLACE ( a)   96 WORD  SWAP OVER C@ 1+ CMOVE ;

: SEARCH ( - f \ search one screen)
   SCR @ BLOCK  DUP  CURSOR @ +  1024 CURSOR @ -
   $FIND $ZMATCH
   IF  SWAP - CURSOR !  -1 EXIT THEN
   2DROP  0 CURSOR !  0 ;





   ( Searching)

VARIABLE SLIM

: <SEARCH> ( - f)
   0 18 AT  ."          "
   RIGHT  SCR @ >R
   BEGIN  SEARCH  IF R> DROP  L  -1 ;THEN
      1 SCR +!  SCR @ SLIM @ >  UNTIL
    R> SCR !  L
   0 18 AT  ." not found"  0 ;

: SEARCHING   <SEARCH> DROP ;

: S ( n)   SLIM !  LEFT  SEARCHING ;

   ( Replacing)

: DELETES ( n)     0 DO  <DELETE>  LOOP ;
: INSERTS ( a #)
   OVER +  BEGIN ( a a')
      2DUP - WHILE  1- DUP C@ <INSERT>  REPEAT  2DROP ;

CREATE $REPLACE   80 ALLOT

: REPLACE   $FIND C@ DELETES  $REPLACE COUNT INSERTS .EOL ;

: >REPLACE   REPLACE  SEARCHING ;

DEFER MORE   ' NOOP IS MORE


( INSERT AND DELETE SCREENS)   DECIMAL

: ?EXTEND-FILE
   CAPACITY 1- BLOCK  1024 -TRAILING IF  DROP  [ FORTH ] 1 MORE
      CR  ." >> 1 screen added to file, any key to continue..."
      7 EMIT  KEY DROP  THEN ;

: REMAINING ( - f t #)   SCR @  DUP 1+  CAPACITY SCR @ - 1- ;

: INSERT-SCR   ?EXTEND-FILE  REMAINING BLOCKS  SCR @ ;
: DELETE-SCR   REMAINING >R SWAP R> BLOCKS CAPACITY 1- ;
: SPREAD
   -DIALOG  ." (I)nsert or (D)elete a screen? "  KEY 32 OR
   ASCII i CASE  ." Insert"  INSERT-SCR  CLEAN L  ;THEN
   ASCII d CASE  ." Delete"  DELETE-SCR  CLEAN L  ;THEN
                 DROP 7 EMIT ." Aborted " ;
   ( Function key interface)
: KEYPAD   KEY
   62 CASE SPREAD ;THEN
   71 CASE HOME   ;THEN            79 CASE TO-EOL ;THEN
   73 CASE B      ;THEN            81 CASE N      ;THEN
   80 CASE DOWN   ;THEN            72 CASE UP     ;THEN
   75 CASE LEFT   ;THEN            77 CASE RIGHT  ;THEN
   82 CASE *INS   ;THEN            83 CASE DELETE ;THEN
   59 CASE FLUSH  ;THEN            60 CASE UNDO L ;THEN
   64 CASE 0 GOTO ;THEN           109 CASE 0 MARK ;THEN
   65 CASE 1 GOTO ;THEN           110 CASE 1 MARK ;THEN
   66 CASE 2 GOTO ;THEN           111 CASE 2 MARK ;THEN
   67 CASE 3 GOTO ;THEN           112 CASE 3 MARK ;THEN
   68 CASE 4 GOTO ;THEN           113 CASE 4 MARK ;THEN
   31 CASE SEARCHING ;THEN         19 CASE REPLACE ;THEN
   44 CASE >REPLACE ;THEN     MORE  7 EMIT DROP ;
   ( Control keys)

: ---   7 EMIT ;
: JAM   KEY CHARACTER ;
VARIABLE FINISHED
: EGRESS   -1 FINISHED ! ;

CREATE CONTROLS
]  ( 00) KEYPAD     <WORD     DIALOG  DOWN4
   ( 04) RIGHT      UP        WORD>   DELETE
   ( 08) BACKSPACE  TAB       BLOT    CUT
   ( 12) PASTE      RETURN    SPLIT   HOME
   ( 16) JAM        SHADOW    UP4     LEFT
   ( 20) -WORD      WIPE      *INS    B
   ( 24) DOWN       JOIN      N       EGRESS
   ( 28) ---        DIALOG    ---     ---       [
( My EDITOR)

ONLY  FORTH ALSO DEFINITIONS
: CONT   [ MYEDIT ]   0 FINISHED !
   BEGIN  .CURSOR  PUT KEY
      DUP 32 < IF  2* CONTROLS + @ EXECUTE
               ELSE  CHARACTER
               THEN
   FINISHED @ UNTIL  0 18 AT  ." Done " ;

: ED   FRAME  [ MYEDIT ] L CONT  ;
: EDIT ( n)   0 MAX CAPACITY 1- MIN  SCR !  ED ;
: R   [ MYEDIT ]  $REPLACE PLACE REPLACE ;
: S   [ MYEDIT ]  $FIND PLACE S ;

ONLY  FORTH ALSO DEFINITIONS
( QX etc)

: QX ( n)   PAD 6 - 27 BLANK  PAGE  0 22 AT
   0 MAX  60 0 DO ( n)
      DUP CAPACITY >= DUP IF  ." QX out of range"  THEN
      KEY? OR  IF LEAVE THEN
      DUP 0 <# #S #> 2DROP  DUP BLOCK PAD 1+  20 CMOVE  1+
      PAD 5 - 26  I 21 /MOD 26 * SWAP 1+ FTYPE
   LOOP  OTHER  SCR ! ;

: NX   SCR @ QX ;
: LX   SCR @ 60 - QX ;
: BX   SCR @ 120 - QX ;

: PRINT   PRINTING ON ;
: ||      12 EMIT  PRINTING OFF ;
( Will Baden's EXPECT)   DECIMAL

: ~ENCODE ( char - a)
   BASE @ >R DECIMAL
   0 <#  BL HOLD  #S  ASCII ~ HOLD  #> ( a #)
   1- OVER 1- C!  1-
   R> BASE ! ;

: ~STROKE ( vector here on special characters)
   drop  KEY ~ENCODE FIND IF  EXECUTE  ELSE  DROP  THEN ;

' ~STROKE CC-FORTH !
' BACK-UP CC-FORTH 27 2* + !

: ~73 ( pgup)   B ;
: ~81 ( pgdn)   N ;
   ( Remembering lines of input)

VARIABLE ^HELD

CREATE HELD   81 8 * ALLOT ( 8 lines of 80 characters + count)
       HELD   81 8 * ERASE

: MCR-IN ( max adr len char)   DROP  DUP SPAN !
   ?DUP IF ( max adr len)
      HELD  DUP 81 +  [ 7 81 * ] LITERAL CMOVE>
      HELD C!  2DUP HELD 1+  ROT CMOVE  THEN
   OVER BL EMIT  -1 ^HELD ! ;

' MCR-IN CC-FORTH 26 + !


   ( Recalling lines of input)

: RETRIEVE ( max adr len ^held - max adr len)
   81 * HELD + >R   0 BACK-UP DROP ( max adr)
   R@ 1+ OVER R@ C@ CMOVE  R@ COUNT TYPE  R> C@ ;

: ~72 ( up arrow \ back one line)
   ^HELD @ 1+ 7 AND  DUP ^HELD ! ( n)  RETRIEVE ;
: ~80 ( down arrow \ forward one line)
   ^HELD @ 1- 7 AND  DUP ^HELD ! ( n)  RETRIEVE ;

: STROKES ( max adr len adr #)
   4 PICK 3 PICK - MIN
   BOUNDS DO I C@ CHAR LOOP ;

\ ie : ~59 ( f1)  " HERE 100 DUMP " STROKES ;
EDIT - an interactive screen editor for F83

by: Rick VanNorman
    1080 Hall Road
    Palm Bay, FL  32905
    (407) 728 0002

This code is released into the public domain.  It may be freely
distributed and used in any way, provided this copyright travels
with it.

(c) 1988 by Rick VanNorman

Thank you for your support.


This editor is the conclusion of 8 years of building screen
editors in Forth.  It is probably the last screen editor that I
will ever write, as I am moving toward a file-based environment.
This editor is compact and very fast, but not always obvious.
I make no appologies for it -- I wrote it, use it, and love it.
It is mine.  I hope you enjoy it.

The extensions included, in my opinion, make F83 a much more
friendly environment.

My thanks to Will Baden for his extensions to EXPECT.




Rick VanNorman  16 February 1989
















Set path

@PATH ( address - )
   Read the current directory as an ASCIIZ string into address+1

!PATH ( address - flag )
   Using the string at address, set a new current directory.  If
   the desired path doesn't exist, return a true flag.

.PATH ( - )
   Read the current path and print it.

CD          usage: CD this/that/path   or:  CD
   Set a new directory to the text following.  If no text
   follows, assume the user desires a report of the current
   directory.
Bios console/printer interface

AT          ( x y)
   Position the cursor at column X, row Y.

XY@         ( - x y)
   Return the X,Y position of the cursor.

VSEG        ( - a)
   A variable holding the video segment address.

COLOR       ( - )
   Sets VSEG for a color display.
MONO        ( - )
   Sets VSEG for a mono-chrome display.

Extended memory access

MY-SEG      ( - seg)
   Return Forth's segment address.
CODE L@     ( seg off - n)
   Read  a 16 bit number from seg:offset .
CODE L!     ( n seg off)
   Write a 16 bit number   to seg:offset .
CODE LCMOVE ( seg-off-f seg-off-t #)
   Move memory, byte by byte, from a segment:offset address
   to a segment:offset address.  The count for the move is
   limited to 65535 bytes.
L2@         ( seg off - d)
   Read  a 32 bit number from seg:offset .
L2!         ( d seg off)
   Write a 32 bit number to   seg:offset .
Faster crt interface

ATTRIBUTE
   The display attribute used by PAGE and FTYPE.
BLANKING
   An indicator of whether the user wishes to blank the display
   before writing characters to it.  Set by "BLANKING ON" in the
   command line invocation of TERM.

+BLANKING
   Conditionally blank the display before continuing.
-BLANKING
   Conditionally unblank the display before continuing.



Faster crt interface

FTYPE ( a # x y)
   This routine (using a fixed attribute) will write a string
   directly into video ram.  It checks blanking for CGA if the
   BLANKING variable is non-zero.  The
   string may be located anywhere on the screen (25x80 only)
   specified by X,Y .

PAGE
   Send the cursor to 0,0 and clear the display.





Listing

OLDSCR   holds the other screen number.
OTHER ( n)   SCR @ = NOT IF  SCR @ OLDSCR !  THEN ;
   If screen N is not the same as SCR, remember SCR in OLDSCR .
FRAME ( n)
   Draw the listing frame specifically for screen N .
<LIST> ( n)
   Display the text of a screen.

LIST ( n)
   While monitoring OTHER, list a given screen.

VIEW            use: VIEW WORDS
   List the screen containing the word specified by lookup
   via the 'VIEW field of the header.
Listing

ADV ( n)   Advance the screen number and list.
L          Relist the current screen.
B          Move back one screen.
N          Move forware one screen.

G           Load the current screen.  My personal favorite word.
O           List the other screen.

Q           Alternate between source and shadow.

CASE        Compile a simple case structure.
            Used as      :  nn CASE ... ;THEN
            Forth code is:  nn OVER = IF DROP ... EXIT THEN
;THEN       Compile an EXIT before a THEN .
Blocks

BLOCKS ( f t #)
   Moves screens just like CMOVE moves bytes.  Never overwrites;
   moves in both directions automatically.
OBLITERATE ( f #)
   Clears a range of screens.  Is difficult to type on purpose.









MYEDIT - moving the cursor

MYEDIT   Is the editor vocabulary.

CURSOR   The cursor position in the current block 0..1023 .
^C ( - a)   Returns the address of the cursor in memory.

+C   A defining word to simplify up, down, etc.

UP     DOWN     RIGHT   simply move the cursor, clipping
UP4    DOWN4    LEFT    at the top and bottom of a screen.

TAB      Moves the cursor to the next "4 MOD" column.
RETURN   Moves the cursor down and to the start of line.

HOME     Moves the cursor to the top of the screen.
Screen interface

XY ( - x y)   Return the x,y position of cursor, crt adjusted.

PUT           Position the physical cursor properly.

#EOL ( - n)   Characters from cursor to the end of line.
#EOS ( - n)   Characters from cursor to start of line 15.

.EOL          Print from cursor to the end of line.
.EOS          Print from cursor to the end of line, continue
              and update remainder of screen.

WIPE          Blanks the screen from cursor to end.
BLOT          Blanks the line   from cursor to end.

Status reporting

SCREENS     Is an array holding the alternate screens.
.SCREENS    Display the alternate screen numbers as status.

INSERTING   Is a variable holding the insert/overwrite state.
.INS        Displays the insert/overwrite state.
*INS        Toggles the insert/overwrite state.

LS          Is a variable pointing to the line stack.
.LS         Prints the top of the line stack below the screen.





Different screens

.CURSOR     Display the x,y cursor position.
.STAT       Update all status displays.

ADV ( n)    Move to another screen, but don't redraw the frame.
N  B        Move +/- one screen.
L           Relist the current screen.
SHADOW      Alternate between source and shadow.
UNDO        Discard changes, re-read from disk.

MARK ( n)   Save the current screen as alternate N .
GOTO ( n)   Move to screen saved as alternate N .

TO-EOL      Move the cursor to the end of the line.

Line stack

CUT         Moves text from the cursor to the end of line to
            the line stack (padded to 64 chars with blanks).
PASTE       Moves text from the line stack to the cursor,
            truncating at the end of the line on the screen.

<DELETE>    Delete the character under the cursor and pull the
            rest of the line over one character.

DELETE      Delete and refresh the display.
BACKSPACE   Move the cursor left.  If we are inserting, delete
            the character under the cursor.



By words

<>END ( n - n f)    true if count N is not at end of screen.
=BL   ( - f)        True if character under cursor is BL .
<>BL  ( - f)        True if character under cursor is not BL .

WORD>               Move right to the start of the next word.
<WORD               Move left  to the start of the next word.

-WORD               Delete the word under the cursor.

DIALOG              Prompt the user a single line of Forth to be
                    executed.  Very handy for calculating
                    constants.


Split and join

SPLIT   Split the current line at the cursor.  Line 15 is lost.
JOIN    Join the current line and the next line at the cursor.

OVERSTRIKE ( char)   Put the character into the buffer and
                     print it on the crt.
<INSERT> ( char)     Insert the character into the buffer.  Move
                     the rest of the line over one column.
                     Refresh the display to the end of the line.
INSERT ( char)       Insert the character and refresh the
                     display to the end of the line.

CHARACTER ( char)    Handle one character.


Matching

$ZMATCH ( sa s# pa - a f)
   Given a source address, the number of bytes in the source
   text, and the address of a counted pattern, check for
   a string match.  Case is significant always.  If a match is
   found, return TRUE and the address of the match.  If no match
   was found, return FALSE ; the address is useless in this
   case.







Searching

$FIND           A buffer for the search pattern.

PLACE ( a)      Parse a string to the address.

SEARCH ( - f)
   Search the current screen for the pattern in $FIND.  If found
   position the cursor at the start of the match and return
   TRUE.  If not found, position the cursor at the top of the
   screen and return FALSE.





Searching

SLIM        Holds the screen number to search thru.

<SEARCH> ( - f)
   Blank the status display and begin searching the screens from
   the current screen through SLIM.  If the string was not found
   return FALSE with the cursor at the top of the screen where
   the search started.  If found, return TRUE and position the
   cursor on the string.

SEARCHING
   Same as <SEARCH> but return no flag.

S ( n)          use:  29 S THIS IS A TEST STRING
   Search thru screen N for the following string.
Replacing

DELETES ( n)    Delete N characters under the cursor.
INSERTS ( a #)  Insert # characters from A at the cursor.

$REPLACE        A buffer for the replace pattern.

REPLACE         Replace text under the cursor.

>REPLACE        Replace and search again.

MORE            A vector for extending the function key
                execution routine.



















Function key interface

KEYPAD
   A function key execution case.  First, read the next key-
   stroke.  Then execute the case statements until a match is
   found.  If no match, execute the MORE extension.  If MORE
   returns, there was no match, so ring the bell and return.
   The keys are referenced by scan codes and are documented
   elsewhere.







Control key interface

---     Rings the bell for undefined control characters.

JAM         Put -any- character into the screen.
FINISHED    True if editing is complete.
EGRESS      Time to exit, set the flag.

CONTROLS    Is a compiled array of execution addresses.  This
            probably should be implemented as  nn CASE .. ;THEN
            for consistency and all that, but this works and I
            don't really care.  The controls are documented
            elsewhere.  Function keys return a zero, which
            vectors to KEYPAD for scan code processing.


My EDITOR

CONT
   Is the main editor loop.  It prints status, accepts keys,
   routes them to either control or text functions, and notices
   when to quit.

ED          Re-edits the current screen.
EDIT ( n)   Edits screen N .

S           Searches for text.
            Use:   29 S this is a test pattern
R           Replaces found text.
            Use:      R this replaces the test pattern

These are used interactively in the dialog routine.
QX etc

QX ( n)
   Prints a quick index (the first 20 characters of each screen
   only) of 60 screens at a time starting at screen N.

NX   Print the next QX .
LX   Print the current QX .
BX   Print the previous QX .

PRINT  vectors console output to the printer.
OK     send a "page feed" to the printer, then vectors console
       output to the display.



Blocks

TRULY       Inquires whether the user really meany what he said.

BLOCKS ( f t #)
   Moves screens just like CMOVE moves bytes.  Never overwrites;
   moves in both directions automatically.
OBLITERATE ( f #)
   Clears a range of screens.  Is difficult to type on purpose.







































